<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="target/&#10;!.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;### IntelliJ IDEA ###&#10;.idea/modules.xml&#10;.idea/jarRepositories.xml&#10;.idea/compiler.xml&#10;.idea/libraries/&#10;*.iws&#10;*.iml&#10;*.ipr&#10;&#10;### Eclipse ###&#10;.apt_generated&#10;.classpath&#10;.factorypath&#10;.project&#10;.settings&#10;.springBeans&#10;.sts4-cache&#10;&#10;### NetBeans ###&#10;/nbproject/private/&#10;/nbbuild/&#10;/dist/&#10;/nbdist/&#10;/.nb-gradle/&#10;build/&#10;!**/src/main/**/build/&#10;!**/src/test/**/build/&#10;&#10;### VS Code ###&#10;.vscode/&#10;&#10;### Mac OS ###&#10;.DS_Store" />
              <option name="updatedContent" value="target/&#10;!.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;### IntelliJ IDEA ###&#10;.idea/modules.xml&#10;.idea/jarRepositories.xml&#10;.idea/compiler.xml&#10;.idea/libraries/&#10;*.iws&#10;*.iml&#10;*.ipr&#10;&#10;### Eclipse ###&#10;.apt_generated&#10;.classpath&#10;.factorypath&#10;.project&#10;.settings&#10;.springBeans&#10;.sts4-cache&#10;&#10;### NetBeans ###&#10;/nbproject/private/&#10;/nbbuild/&#10;/dist/&#10;/nbdist/&#10;/.nb-gradle/&#10;build/&#10;!**/src/main/**/build/&#10;!**/src/test/**/build/&#10;&#10;### VS Code ###&#10;.vscode/&#10;&#10;### Mac OS ###&#10;.DS_Store&#10;&#10;### Application specific ###&#10;logs/&#10;*.log&#10;.env&#10;.env.local&#10;&#10;### Temporary files ###&#10;*.tmp&#10;*.bak&#10;*~" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Rock Paper Scissors&#10;&#10;A console Rock-Paper-Scissors game that I wrote as a coding exercise, focusing on clean code and modern Java practices.&#10;&#10;## What it does&#10;&#10;Simple rock-paper-scissors against the computer. Best of 3 rounds, enter 1/2/3 for your moves, see who wins.&#10;&#10;## Why I built it this way&#10;&#10;I wanted to write simple but fast code, so I made some specific choices:&#10;&#10;- **No string concatenation** - Used `.formatted()` everywhere instead of `+` operator&#10;- **No System.out.println** - Everything goes through `System.Logger` for proper logging&#10;- **Modern Java features** - Records instead of classes where possible, switch expressions, text blocks&#10;- **No external dependencies** - Just standard Java 21, keeping it lightweight&#10;- **Centralized strings** - All text in `GameMessages` constants to avoid hardcoded strings scattered around&#10;&#10;The whole thing uses about 46 meaningful tests and follows some decent patterns like Strategy for different player types.&#10;&#10;## Running it&#10;&#10;Need Java 21+:&#10;&#10;```bash&#10;  mvn compile exec:java&#10;```&#10;&#10;Or build a jar:&#10;```bash&#10;  mvn package&#10;  java -jar target/rock-paper-scissors-1.0.0.jar&#10;```&#10;&#10;Without Maven (manual compilation):&#10;```bash&#10;  javac -d target/classes src/main/java/com/imc/game/*.java src/main/java/com/imc/game/*/*.java&#10;  java -cp target/classes com.imc.game.RockPaperScissorsApplication&#10;```&#10;&#10;## How to play&#10;&#10;1. Type 1 for rock, 2 for paper, 3 for scissors&#10;2. Computer picks randomly&#10;3. Play 3 rounds, best score wins&#10;4. Repeat if you want&#10;&#10;## Code structure&#10;&#10;```&#10;domain/     - game logic (Move enum, GameResult record, etc.)&#10;player/     - HumanPlayer and ComputerPlayer &#10;engine/     - GameEngine that runs rounds&#10;service/    - MatchService for 3-round matches&#10;constants/  - All the text strings in one place&#10;```&#10;&#10;## Testing&#10;&#10;`mvn test`&#10;&#10;Covers all the game logic, input validation, edge cases. Used JUnit 5 and Mockito where needed, but tried to keep most tests simple and focused.&#10;&#10;## Technical details&#10;&#10;- Java 21 with modern features (records, switch expressions, text formatting)&#10;- Zero runtime dependencies &#10;- Clean separation between user interface and system logging&#10;- Strategy pattern for player types (easy to add network players later)&#10;- Immutable data structures where possible&#10;- All user input properly validated with helpful error messages&#10;&#10;Built this as a take-home coding exercise to show clean Java practices without overengineering.&#10;" />
              <option name="updatedContent" value="# Rock Paper Scissors&#10;&#10;A console Rock-Paper-Scissors game that I wrote as a coding exercise, focusing on clean code and modern Java practices.&#10;&#10;## What it does&#10;&#10;Simple rock-paper-scissors against the computer. Best of 3 rounds, enter 1/2/3 for your moves, see who wins.&#10;&#10;## Why I built it this way&#10;&#10;I wanted to write simple but fast code, so I made some specific choices:&#10;&#10;- **No string concatenation** - Used `.formatted()` everywhere instead of `+` operator&#10;- **No System.out.println** - Everything goes through `System.Logger` for proper logging&#10;- **Modern Java features** - Records instead of classes where possible, switch expressions, text blocks&#10;- **No external dependencies** - Just standard Java 21, keeping it lightweight&#10;- **Centralized strings** - All text in `GameMessages` constants to avoid hardcoded strings scattered around&#10;&#10;The whole thing uses about 46 meaningful tests and follows some decent patterns like Strategy for different player types.&#10;&#10;## Running it&#10;&#10;Need Java 21+:&#10;&#10;```bash&#10;  mvn compile exec:java&#10;```&#10;&#10;Or build a jar:&#10;```bash&#10;  mvn package&#10;  java -jar target/rock-paper-scissors-1.0.0.jar&#10;```&#10;&#10;Without Maven (manual compilation):&#10;```bash&#10;  javac -d target/classes src/main/java/com/imc/game/*.java src/main/java/com/imc/game/*/*.java&#10;  java -cp target/classes com.imc.game.RockPaperScissorsApplication&#10;```&#10;&#10;## How to play&#10;&#10;1. Type 1 for rock, 2 for paper, 3 for scissors&#10;2. Computer picks randomly&#10;3. Play 3 rounds, best score wins&#10;4. Repeat if you want&#10;&#10;## Code structure&#10;&#10;```&#10;domain/     - game logic (Move enum, GameResult record, etc.)&#10;player/     - HumanPlayer and ComputerPlayer &#10;engine/     - GameEngine that runs rounds&#10;service/    - MatchService for 3-round matches&#10;constants/  - All the text strings in one place&#10;```&#10;&#10;## Testing&#10;&#10;`mvn test`&#10;&#10;Covers all the game logic, input validation, edge cases. Used JUnit 5 and Mockito where needed, but tried to keep most tests simple and focused.&#10;&#10;The computer randomness is tested by running it until all three moves appear (usually takes way less than the 1000 attempt limit).&#10;&#10;## Development&#10;&#10;Built with:&#10;- Java 21 (required)&#10;- Maven 3.6+ (optional, can compile manually)&#10;- Any IDE that supports Java 21&#10;&#10;The code uses modern Java features like records and switch expressions, so older Java versions won't work.&#10;&#10;All dependencies are test-only (JUnit 5, Mockito) - the runtime has zero external dependencies.&#10;&#10;## Technical details&#10;&#10;- Java 21 with modern features (records, switch expressions, text formatting)&#10;- Zero runtime dependencies &#10;- Clean separation between user interface and system logging&#10;- Strategy pattern for player types (easy to add network players later)&#10;- Immutable data structures where possible&#10;- All user input properly validated with helpful error messages&#10;&#10;Built this as a take-home coding exercise to show clean Java practices without overengineering." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.imc.game&lt;/groupId&gt;&#10;    &lt;artifactId&gt;rock-paper-scissors&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;Rock Paper Scissors Game&lt;/name&gt;&#10;    &lt;description&gt;A production-ready console Rock-Paper-Scissors game built with modern Java 21&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&#10;&#10;        &lt;!-- Dependency versions --&gt;&#10;        &lt;junit.version&gt;5.10.0&lt;/junit.version&gt;&#10;        &lt;mockito.version&gt;5.14.2&lt;/mockito.version&gt;&#10;&#10;        &lt;!-- Plugin versions --&gt;&#10;        &lt;maven.compiler.version&gt;3.13.0&lt;/maven.compiler.version&gt;&#10;        &lt;maven.surefire.version&gt;3.2.5&lt;/maven.surefire.version&gt;&#10;        &lt;maven.jar.version&gt;3.4.2&lt;/maven.jar.version&gt;&#10;        &lt;exec.maven.version&gt;3.4.1&lt;/exec.maven.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;${junit.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.mockito&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${mockito.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt;&#10;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.compiler.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;release&gt;${maven.compiler.release}&lt;/release&gt;&#10;                    &lt;compilerArgs&gt;&#10;                        &lt;arg&gt;-Xlint:all&lt;/arg&gt;&#10;                        &lt;arg&gt;-Werror&lt;/arg&gt;&#10;                    &lt;/compilerArgs&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Test Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.surefire.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*Test.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- JAR Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.jar.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;mainClass&gt;com.imc.game.RockPaperScissorsApplication&lt;/mainClass&gt;&#10;                            &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;&#10;                            &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Exec Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;&#10;                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${exec.maven.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;mainClass&gt;com.imc.game.RockPaperScissorsApplication&lt;/mainClass&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.imc.game&lt;/groupId&gt;&#10;    &lt;artifactId&gt;rock-paper-scissors&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;Rock Paper Scissors Game&lt;/name&gt;&#10;    &lt;description&gt;A console Rock-Paper-Scissors game built with modern Java 21 as a coding exercise&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&#10;&#10;        &lt;!-- Dependency versions --&gt;&#10;        &lt;junit.version&gt;5.10.0&lt;/junit.version&gt;&#10;        &lt;mockito.version&gt;5.14.2&lt;/mockito.version&gt;&#10;&#10;        &lt;!-- Plugin versions --&gt;&#10;        &lt;maven.compiler.version&gt;3.13.0&lt;/maven.compiler.version&gt;&#10;        &lt;maven.surefire.version&gt;3.2.5&lt;/maven.surefire.version&gt;&#10;        &lt;maven.jar.version&gt;3.4.2&lt;/maven.jar.version&gt;&#10;        &lt;exec.maven.version&gt;3.4.1&lt;/exec.maven.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;${junit.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.mockito&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${mockito.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt;&#10;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.compiler.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;release&gt;${maven.compiler.release}&lt;/release&gt;&#10;                    &lt;compilerArgs&gt;&#10;                        &lt;arg&gt;-Xlint:all&lt;/arg&gt;&#10;                    &lt;/compilerArgs&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Test Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.surefire.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*Test.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- JAR Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.jar.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;mainClass&gt;com.imc.game.RockPaperScissorsApplication&lt;/mainClass&gt;&#10;                            &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;&#10;                            &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Exec Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;&#10;                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${exec.maven.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;mainClass&gt;com.imc.game.RockPaperScissorsApplication&lt;/mainClass&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/RockPaperScissorsApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/RockPaperScissorsApplication.java" />
              <option name="originalContent" value="package com.imc.game;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.Player;&#10;import com.imc.game.engine.GameEngine;&#10;import com.imc.game.player.ComputerPlayer;&#10;import com.imc.game.player.HumanPlayer;&#10;import com.imc.game.service.MatchResult;&#10;import com.imc.game.service.MatchService;&#10;&#10;import java.util.Scanner;&#10;&#10;public class RockPaperScissorsApplication {&#10;&#10;    private static final System.Logger logger = System.getLogger(RockPaperScissorsApplication.class.getName());&#10;&#10;    public static void main(String[] args) {&#10;        // show only messages without timestamps/class names&#10;        System.setProperty(&quot;java.util.logging.SimpleFormatter.format&quot;, &quot;%5$s%n&quot;);&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.APP_STARTING);&#10;&#10;        try (Scanner scanner = new Scanner(System.in)) {&#10;            new RockPaperScissorsApplication().run(scanner);&#10;        } catch (Exception e) {&#10;            logger.log(System.Logger.Level.ERROR, GameMessages.APPLICATION_ERROR, e);&#10;            logger.log(System.Logger.Level.ERROR, GameMessages.UNEXPECTED_ERROR, e.getMessage());&#10;        }&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.APP_TERMINATED);&#10;    }&#10;&#10;    public void run(Scanner scanner) {&#10;        MatchService matchService = new MatchService(new GameEngine());&#10;        boolean playAgain;&#10;&#10;        do {&#10;            MatchResult result = playMatch(matchService, scanner);&#10;            displayMatchResult(result);&#10;            playAgain = askPlayAgain(scanner);&#10;        } while (playAgain);&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.THANKS_FOR_PLAYING);&#10;    }&#10;&#10;    private MatchResult playMatch(MatchService matchService, Scanner scanner) {&#10;        Player humanPlayer = new HumanPlayer(&quot;Player&quot;, scanner, logger);&#10;        Player computerPlayer = new ComputerPlayer(&quot;Computer&quot;);&#10;        return matchService.playMatch(humanPlayer, computerPlayer);&#10;    }&#10;&#10;    private void displayMatchResult(MatchResult result) {&#10;        logger.log(System.Logger.Level.INFO, GameMessages.FINAL_RESULT_HEADER);&#10;&#10;        if (result.isTied()) {&#10;            logger.log(System.Logger.Level.INFO, GameMessages.MATCH_TIED,&#10;                    result.player1Wins(), result.player2Wins());&#10;        } else {&#10;            logger.log(System.Logger.Level.INFO, GameMessages.MATCH_WON,&#10;                    result.getWinnerName(),&#10;                    result.isPlayer1Winner() ? result.player1Wins() : result.player2Wins(),&#10;                    result.isPlayer1Winner() ? result.player2Wins() : result.player1Wins());&#10;        }&#10;    }&#10;&#10;    private boolean askPlayAgain(Scanner scanner) {&#10;        logger.log(System.Logger.Level.INFO, GameMessages.PLAY_AGAIN_PROMPT);&#10;        String choice = scanner.nextLine().trim().toLowerCase();&#10;        return choice.startsWith(&quot;y&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.Player;&#10;import com.imc.game.engine.GameEngine;&#10;import com.imc.game.player.ComputerPlayer;&#10;import com.imc.game.player.HumanPlayer;&#10;import com.imc.game.service.MatchResult;&#10;import com.imc.game.service.MatchService;&#10;&#10;import java.util.Scanner;&#10;&#10;public class RockPaperScissorsApplication {&#10;&#10;    private static final System.Logger logger = System.getLogger(RockPaperScissorsApplication.class.getName());&#10;&#10;    public static void main(String[] args) {&#10;        // show only messages without timestamps/class names&#10;        System.setProperty(&quot;java.util.logging.SimpleFormatter.format&quot;, &quot;%5$s%n&quot;);&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.APP_STARTING);&#10;&#10;        try (Scanner scanner = new Scanner(System.in)) {&#10;            new RockPaperScissorsApplication().run(scanner);&#10;        } catch (Exception e) {&#10;            logger.log(System.Logger.Level.ERROR, GameMessages.APPLICATION_ERROR, e);&#10;            logger.log(System.Logger.Level.ERROR, GameMessages.UNEXPECTED_ERROR, e.getMessage());&#10;        }&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.APP_TERMINATED);&#10;    }&#10;&#10;    public void run(Scanner scanner) {&#10;        MatchService matchService = new MatchService(new GameEngine());&#10;        boolean playAgain;&#10;&#10;        do {&#10;            MatchResult result = playMatch(matchService, scanner);&#10;            displayMatchResult(result);&#10;            playAgain = askPlayAgain(scanner);&#10;        } while (playAgain);&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.THANKS_FOR_PLAYING);&#10;    }&#10;&#10;    private MatchResult playMatch(MatchService matchService, Scanner scanner) {&#10;        Player humanPlayer = new HumanPlayer(GameMessages.DEFAULT_PLAYER_NAME, scanner, logger);&#10;        Player computerPlayer = new ComputerPlayer(GameMessages.DEFAULT_COMPUTER_NAME);&#10;        return matchService.playMatch(humanPlayer, computerPlayer);&#10;    }&#10;&#10;    private void displayMatchResult(MatchResult result) {&#10;        logger.log(System.Logger.Level.INFO, GameMessages.FINAL_RESULT_HEADER);&#10;&#10;        if (result.isTied()) {&#10;            logger.log(System.Logger.Level.INFO, GameMessages.MATCH_TIED,&#10;                    result.player1Wins(), result.player2Wins());&#10;        } else {&#10;            int winnerScore = result.isPlayer1Winner() ? result.player1Wins() : result.player2Wins();&#10;            int loserScore = result.isPlayer1Winner() ? result.player2Wins() : result.player1Wins();&#10;&#10;            logger.log(System.Logger.Level.INFO, GameMessages.MATCH_WON,&#10;                    result.getWinnerName(), winnerScore, loserScore);&#10;        }&#10;    }&#10;&#10;    private boolean askPlayAgain(Scanner scanner) {&#10;        logger.log(System.Logger.Level.INFO, GameMessages.PLAY_AGAIN_PROMPT);&#10;        String choice = scanner.nextLine().trim().toLowerCase();&#10;        return choice.startsWith(&quot;y&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/constants/GameMessages.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/constants/GameMessages.java" />
              <option name="originalContent" value="package com.imc.game.constants;&#10;&#10;/**&#10; * Central location for all text constants used in the Rock-Paper-Scissors game.&#10; * Makes the application easier to maintain and potentially internationalize.&#10; */&#10;public final class GameMessages {&#10;&#10;    // Application lifecycle messages&#10;    public static final String APP_STARTING = &quot;Starting Rock-Paper-Scissors application&quot;;&#10;    public static final String APP_TERMINATED = &quot;Application terminated&quot;;&#10;    public static final String THANKS_FOR_PLAYING = &quot;Thanks for playing!&quot;;&#10;    public static final String APPLICATION_ERROR = &quot;Application error&quot;;&#10;    public static final String UNEXPECTED_ERROR = &quot;An unexpected error occurred: {0}&quot;;&#10;&#10;    // Match and round messages&#10;    public static final String ROUND_HEADER = &quot;\n--- Round {0} ---&quot;;&#10;    public static final String FINAL_RESULT_HEADER = &quot;\n=== FINAL RESULT ===&quot;;&#10;    public static final String SCORE_FORMAT = &quot;Score: {0} {1} - {2} {3}&quot;;&#10;    public static final String MATCH_TIED = &quot;Match tied! Final score: {0}-{1}&quot;;&#10;    public static final String MATCH_WON = &quot;{0} won the match! Final score: {1}-{2}&quot;;&#10;&#10;    // User interaction messages&#10;    public static final String PLAY_AGAIN_PROMPT = &quot;Play another match? (y/n): &quot;;&#10;    public static final String CHOOSE_MOVE = &quot;Choose your move:&quot;;&#10;    public static final String ENTER_CHOICE = &quot;Enter your choice: &quot;;&#10;&#10;    // Input validation messages&#10;    public static final String PLEASE_ENTER_NUMBER = &quot;Please enter a number.&quot;;&#10;    public static final String INVALID_INPUT_FORMAT = &quot;Invalid input. Please enter a number (1, 2, or 3).&quot;;&#10;    public static final String INVALID_INPUT_RANGE = &quot;Please enter 1, 2, or 3.&quot;;&#10;&#10;    // Game result messages&#10;    public static final String DRAW = &quot;Draw!&quot;;&#10;    public static final String PLAYER_WINS = &quot;{0} wins!&quot;;&#10;    public static final String MOVES_FORMAT = &quot;{0} chose {1}, {2} chose {3}&quot;;&#10;&#10;    // Battle descriptions&#10;    public static final String BEATS_FORMAT = &quot;{0} beats {1}&quot;;&#10;    public static final String BOTH_CHOSE = &quot;Both players chose {0}&quot;;&#10;&#10;    // Move option format&#10;    public static final String MOVE_OPTION_FORMAT = &quot;%d - %s&quot;;&#10;&#10;    // Logging messages&#10;    public static final String GETTING_MOVE_FOR_PLAYER = &quot;Getting move for player: {0}&quot;;&#10;    public static final String PLAYER_CHOSE = &quot;Player chose {0}&quot;;&#10;    public static final String COMPUTER_CHOSE = &quot;Computer chose {0}&quot;;&#10;    public static final String STARTING_ROUND = &quot;Starting round between {0} and {1}&quot;;&#10;    public static final String INVALID_NUMBER_FORMAT = &quot;Invalid number format from player&quot;;&#10;    public static final String INVALID_MOVE_CHOICE = &quot;Invalid move choice: {0}&quot;;&#10;    public static final String ERROR_DURING_ROUND = &quot;Error during round&quot;;&#10;    public static final String ERROR_CONTINUING = &quot;Error in round. Continuing...&quot;;&#10;&#10;    // Private constructor to prevent instantiation&#10;    private GameMessages() {&#10;        throw new UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.constants;&#10;&#10;/**&#10; * Central location for all text constants used in the Rock-Paper-Scissors game.&#10; * Makes the application easier to maintain and potentially internationalize.&#10; */&#10;public final class GameMessages {&#10;&#10;    // Application lifecycle messages&#10;    public static final String APP_STARTING = &quot;Starting Rock-Paper-Scissors application&quot;;&#10;    public static final String APP_TERMINATED = &quot;Application terminated&quot;;&#10;    public static final String THANKS_FOR_PLAYING = &quot;Thanks for playing!&quot;;&#10;    public static final String APPLICATION_ERROR = &quot;Application error&quot;;&#10;    public static final String UNEXPECTED_ERROR = &quot;An unexpected error occurred: {0}&quot;;&#10;&#10;    // Match and round messages&#10;    public static final String ROUND_HEADER = &quot;\n--- Round {0} ---&quot;;&#10;    public static final String FINAL_RESULT_HEADER = &quot;\n=== FINAL RESULT ===&quot;;&#10;    public static final String SCORE_FORMAT = &quot;Score: {0} {1} - {2} {3}&quot;;&#10;    public static final String MATCH_TIED = &quot;Match tied! Final score: {0}-{1}&quot;;&#10;    public static final String MATCH_WON = &quot;{0} won the match! Final score: {1}-{2}&quot;;&#10;&#10;    // User interaction messages&#10;    public static final String PLAY_AGAIN_PROMPT = &quot;Play another match? (y/n): &quot;;&#10;    public static final String CHOOSE_MOVE = &quot;Choose your move:&quot;;&#10;    public static final String ENTER_CHOICE = &quot;Enter your choice: &quot;;&#10;&#10;    // Input validation messages&#10;    public static final String PLEASE_ENTER_NUMBER = &quot;Please enter a number.&quot;;&#10;    public static final String INVALID_INPUT_FORMAT = &quot;Invalid input. Please enter a number (1, 2, or 3).&quot;;&#10;    public static final String INVALID_INPUT_RANGE = &quot;Please enter 1, 2, or 3.&quot;;&#10;&#10;    // Game result messages&#10;    public static final String DRAW = &quot;Draw!&quot;;&#10;    public static final String PLAYER_WINS = &quot;{0} wins!&quot;;&#10;    public static final String MOVES_FORMAT = &quot;{0} chose {1}, {2} chose {3}&quot;;&#10;&#10;    // Move option format&#10;    public static final String MOVE_OPTION_FORMAT = &quot;%d - %s&quot;;&#10;&#10;    // Logging messages&#10;    public static final String GETTING_MOVE_FOR_PLAYER = &quot;Getting move for player: {0}&quot;;&#10;    public static final String PLAYER_CHOSE = &quot;Player chose {0}&quot;;&#10;    public static final String COMPUTER_CHOSE = &quot;Computer chose {0}&quot;;&#10;    public static final String STARTING_ROUND = &quot;Starting round between {0} and {1}&quot;;&#10;    public static final String INVALID_NUMBER_FORMAT = &quot;Invalid number format from player&quot;;&#10;    public static final String INVALID_MOVE_CHOICE = &quot;Invalid move choice: {0}&quot;;&#10;&#10;    // Player names&#10;    public static final String DEFAULT_PLAYER_NAME = &quot;Player&quot;;&#10;    public static final String DEFAULT_COMPUTER_NAME = &quot;Computer&quot;;&#10;&#10;    // Private constructor to prevent instantiation&#10;    private GameMessages() {&#10;        throw new UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/domain/BattleResult.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/domain/BattleResult.java" />
              <option name="updatedContent" value="package com.imc.game.domain;&#10;&#10;/**&#10; * Represents the outcome of a single move comparison in Rock-Paper-Scissors.&#10; */&#10;public enum BattleResult {&#10;    WIN(&quot;wins&quot;),&#10;    LOSE(&quot;loses&quot;), &#10;    DRAW(&quot;draws&quot;);&#10;&#10;    private final String description;&#10;&#10;    BattleResult(String description) {&#10;        this.description = description;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/domain/GameResult.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/domain/GameResult.java" />
              <option name="originalContent" value="package com.imc.game.domain;&#10;&#10;public record GameResult(&#10;    String player1Name,&#10;    Move player1Move,&#10;    String player2Name,&#10;    Move player2Move,&#10;    BattleResult player1Result,&#10;    String winnerName&#10;) {&#10;&#10;    /**&#10;     * Factory method to create a GameResult from two player moves.&#10;     */&#10;    public static GameResult of(String player1Name, Move player1Move,&#10;                               String player2Name, Move player2Move) {&#10;        BattleResult player1Result = player1Move.against(player2Move);&#10;&#10;        String winnerName = switch (player1Result) {&#10;            case WIN -&gt; player1Name;&#10;            case LOSE -&gt; player2Name;&#10;            case DRAW -&gt; null; // No winner in case of draw&#10;        };&#10;&#10;        return new GameResult(player1Name, player1Move, player2Name, player2Move,&#10;                            player1Result, winnerName);&#10;    }&#10;&#10;    public boolean isDraw() {&#10;        return player1Result == BattleResult.DRAW;&#10;    }&#10;&#10;    /**&#10;     * Returns a formatted description of what happened in the battle.&#10;     */&#10;    public String getBattleDescription() {&#10;        return switch (player1Result) {&#10;            case WIN -&gt; &quot;%s beats %s&quot;.formatted(&#10;                player1Move.getDisplayName(),&#10;                player2Move.getDisplayName()&#10;            );&#10;            case LOSE -&gt; &quot;%s beats %s&quot;.formatted(&#10;                player2Move.getDisplayName(),&#10;                player1Move.getDisplayName()&#10;            );&#10;            case DRAW -&gt; &quot;Both players chose %s&quot;.formatted(player1Move.getDisplayName());&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.domain;&#10;&#10;public record GameResult(&#10;    String player1Name,&#10;    Move player1Move,&#10;    String player2Name,&#10;    Move player2Move,&#10;    BattleResult player1Result,&#10;    String winnerName&#10;) {&#10;&#10;    /**&#10;     * Factory method to create a GameResult from two player moves.&#10;     */&#10;    public static GameResult of(String player1Name, Move player1Move,&#10;                               String player2Name, Move player2Move) {&#10;        BattleResult player1Result = player1Move.against(player2Move);&#10;&#10;        String winnerName = switch (player1Result) {&#10;            case WIN -&gt; player1Name;&#10;            case LOSE -&gt; player2Name;&#10;            case DRAW -&gt; null; // No winner in case of draw&#10;        };&#10;&#10;        return new GameResult(player1Name, player1Move, player2Name, player2Move,&#10;                            player1Result, winnerName);&#10;    }&#10;&#10;    public boolean isDraw() {&#10;        return player1Result == BattleResult.DRAW;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/domain/Move.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/domain/Move.java" />
              <option name="originalContent" value="package com.imc.game.domain;&#10;&#10;public enum Move {&#10;    ROCK(1, &quot;Rock&quot;),&#10;    PAPER(2, &quot;Paper&quot;),&#10;    SCISSORS(3, &quot;Scissors&quot;);&#10;&#10;    private final int inputValue;&#10;    private final String displayName;&#10;&#10;    Move(int inputValue, String displayName) {&#10;        this.inputValue = inputValue;&#10;        this.displayName = displayName;&#10;    }&#10;&#10;    /**&#10;     * Creates a Move from user input (1, 2, or 3).&#10;     *&#10;     * @param input the numeric input from user&#10;     * @return the corresponding Move&#10;     * @throws IllegalArgumentException if input is not 1, 2, or 3&#10;     */&#10;    public static Move fromInput(int input) {&#10;        return switch (input) {&#10;            case 1 -&gt; ROCK;&#10;            case 2 -&gt; PAPER;&#10;            case 3 -&gt; SCISSORS;&#10;            default -&gt; throw new IllegalArgumentException(&quot;Please enter 1, 2, or 3.&quot;);&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Determines if this move beats the other move.&#10;     * Uses pattern matching for clear game logic.&#10;     */&#10;    public boolean beats(Move other) {&#10;        return switch (this) {&#10;            case ROCK -&gt; other == SCISSORS;     // Rock beats (blunts) scissors&#10;            case PAPER -&gt; other == ROCK;        // Paper beats (wraps) rock&#10;            case SCISSORS -&gt; other == PAPER;    // Scissors beats (cuts) paper&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Compares this move against another and returns the battle result.&#10;     */&#10;    public BattleResult against(Move other) {&#10;        if (this.beats(other)) {&#10;            return BattleResult.WIN;&#10;        } else if (other.beats(this)) {&#10;            return BattleResult.LOSE;&#10;        } else {&#10;            return BattleResult.DRAW;&#10;        }&#10;    }&#10;&#10;    public int getInputValue() {&#10;        return inputValue;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    /**&#10;     * Returns a formatted string showing the input option.&#10;     */&#10;    public String getInputOption() {&#10;        return &quot;%d - %s&quot;.formatted(inputValue, displayName);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.domain;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;&#10;public enum Move {&#10;    ROCK(1, &quot;Rock&quot;),&#10;    PAPER(2, &quot;Paper&quot;),&#10;    SCISSORS(3, &quot;Scissors&quot;);&#10;&#10;    private final int inputValue;&#10;    private final String displayName;&#10;&#10;    Move(int inputValue, String displayName) {&#10;        this.inputValue = inputValue;&#10;        this.displayName = displayName;&#10;    }&#10;&#10;    /**&#10;     * Creates a Move from user input (1, 2, or 3).&#10;     *&#10;     * @param input the numeric input from user&#10;     * @return the corresponding Move&#10;     * @throws IllegalArgumentException if input is not 1, 2, or 3&#10;     */&#10;    public static Move fromInput(int input) {&#10;        return switch (input) {&#10;            case 1 -&gt; ROCK;&#10;            case 2 -&gt; PAPER;&#10;            case 3 -&gt; SCISSORS;&#10;            default -&gt; throw new IllegalArgumentException(GameMessages.INVALID_INPUT_RANGE);&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Determines if this move beats the other move.&#10;     * Uses pattern matching for clear game logic.&#10;     */&#10;    public boolean beats(Move other) {&#10;        return switch (this) {&#10;            case ROCK -&gt; other == SCISSORS;     // Rock beats (blunts) scissors&#10;            case PAPER -&gt; other == ROCK;        // Paper beats (wraps) rock&#10;            case SCISSORS -&gt; other == PAPER;    // Scissors beats (cuts) paper&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Compares this move against another and returns the battle result.&#10;     */&#10;    public BattleResult against(Move other) {&#10;        if (this.beats(other)) {&#10;            return BattleResult.WIN;&#10;        } else if (other.beats(this)) {&#10;            return BattleResult.LOSE;&#10;        } else {&#10;            return BattleResult.DRAW;&#10;        }&#10;    }&#10;&#10;    public int getInputValue() {&#10;        return inputValue;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    /**&#10;     * Returns a formatted string showing the input option.&#10;     */&#10;    public String getInputOption() {&#10;        return GameMessages.MOVE_OPTION_FORMAT.formatted(inputValue, displayName);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/domain/Player.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/domain/Player.java" />
              <option name="updatedContent" value="package com.imc.game.domain;&#10;&#10;/**&#10; * Strategy pattern interface for different types of players.&#10; * Allows for easy extension with different player implementations.&#10; */&#10;public interface Player {&#10;    &#10;    /**&#10;     * Gets the player's name for display purposes.&#10;     */&#10;    String getName();&#10;    &#10;    /**&#10;     * Gets the player's move choice.&#10;     * Implementation depends on player type (human input, AI, etc.).&#10;     */&#10;    Move getMove();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/engine/GameEngine.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/engine/GameEngine.java" />
              <option name="originalContent" value="package com.imc.game.engine;&#10;&#10;import com.imc.game.domain.GameResult;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;&#10;public class GameEngine {&#10;&#10;    private static final System.Logger logger = System.getLogger(GameEngine.class.getName());&#10;&#10;    public GameResult playRound(Player player1, Player player2) {&#10;        logger.log(System.Logger.Level.INFO, &quot;Starting round between {0} and {1}&quot;,&#10;                  player1.getName(), player2.getName());&#10;&#10;        Move player1Move = player1.getMove();&#10;        Move player2Move = player2.getMove();&#10;&#10;        GameResult result = GameResult.of(&#10;            player1.getName(), player1Move,&#10;            player2.getName(), player2Move&#10;        );&#10;&#10;        return result;&#10;    }&#10;&#10;    public void displayResult(GameResult result) {&#10;        logger.log(System.Logger.Level.INFO, &quot;{0} chose {1}, {2} chose {3}&quot;,&#10;            result.player1Name(), result.player1Move().getDisplayName(),&#10;            result.player2Name(), result.player2Move().getDisplayName());&#10;&#10;        if (result.isDraw()) {&#10;            logger.log(System.Logger.Level.INFO, &quot;Draw!&quot;);&#10;        } else {&#10;            logger.log(System.Logger.Level.INFO, &quot;{0} wins!&quot;, result.winnerName());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.engine;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.GameResult;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;&#10;public class GameEngine {&#10;&#10;    private static final System.Logger logger = System.getLogger(GameEngine.class.getName());&#10;&#10;    public GameResult playRound(Player player1, Player player2) {&#10;        logger.log(System.Logger.Level.INFO, GameMessages.STARTING_ROUND,&#10;                  player1.getName(), player2.getName());&#10;&#10;        Move player1Move = player1.getMove();&#10;        Move player2Move = player2.getMove();&#10;&#10;        GameResult result = GameResult.of(&#10;            player1.getName(), player1Move,&#10;            player2.getName(), player2Move&#10;        );&#10;&#10;        return result;&#10;    }&#10;&#10;    public void displayResult(GameResult result) {&#10;        logger.log(System.Logger.Level.INFO, GameMessages.MOVES_FORMAT,&#10;            result.player1Name(), result.player1Move().getDisplayName(),&#10;            result.player2Name(), result.player2Move().getDisplayName());&#10;        &#10;        if (result.isDraw()) {&#10;            logger.log(System.Logger.Level.INFO, GameMessages.DRAW);&#10;        } else {&#10;            logger.log(System.Logger.Level.INFO, GameMessages.PLAYER_WINS, result.winnerName());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/player/ComputerPlayer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/player/ComputerPlayer.java" />
              <option name="originalContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;&#10;import java.security.SecureRandom;&#10;&#10;public class ComputerPlayer implements Player {&#10;&#10;    private static final System.Logger logger = System.getLogger(ComputerPlayer.class.getName());&#10;&#10;    private final String name;&#10;    private final SecureRandom random;&#10;    private final Move[] moves;&#10;&#10;    public ComputerPlayer(String name) {&#10;        this.name = name;&#10;        this.random = new SecureRandom();&#10;        this.moves = Move.values();&#10;    }&#10;&#10;    @Override&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    @Override&#10;    public Move getMove() {&#10;        Move selectedMove = moves[random.nextInt(moves.length)];&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.COMPUTER_CHOSE, selectedMove.getDisplayName());&#10;&#10;        return selectedMove;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;&#10;import java.util.Random;&#10;&#10;/**&#10; * Computer player implementation that makes random move selections.&#10; * Uses Random for game move selection - SecureRandom would be overkill.&#10; */&#10;public class ComputerPlayer implements Player {&#10;&#10;    private static final System.Logger logger = System.getLogger(ComputerPlayer.class.getName());&#10;&#10;    private final String name;&#10;    private final Random random;&#10;    private final Move[] moves;&#10;&#10;    public ComputerPlayer(String name) {&#10;        this.name = name;&#10;        this.random = new Random();&#10;        this.moves = Move.values();&#10;    }&#10;&#10;    @Override&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    @Override&#10;    public Move getMove() {&#10;        Move selectedMove = moves[random.nextInt(moves.length)];&#10;&#10;        logger.log(System.Logger.Level.INFO, GameMessages.COMPUTER_CHOSE, selectedMove.getDisplayName());&#10;&#10;        return selectedMove;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/player/HumanPlayer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/player/HumanPlayer.java" />
              <option name="originalContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;&#10;import java.util.Scanner;&#10;&#10;public class HumanPlayer implements Player {&#10;&#10;    private static final System.Logger logger = System.getLogger(HumanPlayer.class.getName());&#10;&#10;    private final String name;&#10;    private final Scanner scanner;&#10;    private final System.Logger outputLogger;&#10;&#10;    public HumanPlayer(String name, Scanner scanner, System.Logger outputLogger) {&#10;        this.name = name;&#10;        this.scanner = scanner;&#10;        this.outputLogger = outputLogger;&#10;    }&#10;&#10;    @Override&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    @Override&#10;    public Move getMove() {&#10;        logger.log(System.Logger.Level.DEBUG, &quot;Getting move for player: {0}&quot;, name);&#10;&#10;        while (true) {&#10;            displayMoveOptions();&#10;            outputLogger.log(System.Logger.Level.INFO, &quot;Enter your choice: &quot;);&#10;&#10;            try {&#10;                String input = scanner.nextLine().trim();&#10;&#10;                if (input.isEmpty()) {&#10;                    outputLogger.log(System.Logger.Level.WARNING, &quot;Please enter a number.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                int choice = Integer.parseInt(input);&#10;                Move move = Move.fromInput(choice);&#10;&#10;                logger.log(System.Logger.Level.INFO, &quot;Player chose {0}&quot;, move.getDisplayName());&#10;                return move;&#10;&#10;            } catch (NumberFormatException e) {&#10;                outputLogger.log(System.Logger.Level.WARNING, &quot;Invalid input. Please enter a number (1, 2, or 3).&quot;);&#10;                logger.log(System.Logger.Level.DEBUG, &quot;Invalid number format from player&quot;);&#10;            } catch (IllegalArgumentException e) {&#10;                outputLogger.log(System.Logger.Level.WARNING, e.getMessage());&#10;                logger.log(System.Logger.Level.DEBUG, &quot;Invalid move choice: {0}&quot;, e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    private void displayMoveOptions() {&#10;        StringBuilder options = new StringBuilder(&quot;Choose your move:\n&quot;);&#10;        for (Move move : Move.values()) {&#10;            options.append(&quot;  &quot;).append(move.getInputOption()).append(&quot;\n&quot;);&#10;        }&#10;        outputLogger.log(System.Logger.Level.INFO, options.toString().trim());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;&#10;import java.util.Scanner;&#10;&#10;public class HumanPlayer implements Player {&#10;&#10;    private static final System.Logger logger = System.getLogger(HumanPlayer.class.getName());&#10;&#10;    private final String name;&#10;    private final Scanner scanner;&#10;    private final System.Logger outputLogger;&#10;&#10;    public HumanPlayer(String name, Scanner scanner, System.Logger outputLogger) {&#10;        this.name = name;&#10;        this.scanner = scanner;&#10;        this.outputLogger = outputLogger;&#10;    }&#10;&#10;    @Override&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    @Override&#10;    public Move getMove() {&#10;        logger.log(System.Logger.Level.DEBUG, GameMessages.GETTING_MOVE_FOR_PLAYER, name);&#10;&#10;        while (true) {&#10;            displayMoveOptions();&#10;            outputLogger.log(System.Logger.Level.INFO, GameMessages.ENTER_CHOICE);&#10;&#10;            try {&#10;                String input = scanner.nextLine().trim();&#10;&#10;                if (input.isEmpty()) {&#10;                    outputLogger.log(System.Logger.Level.WARNING, GameMessages.PLEASE_ENTER_NUMBER);&#10;                    continue;&#10;                }&#10;&#10;                int choice = Integer.parseInt(input);&#10;                Move move = Move.fromInput(choice);&#10;&#10;                logger.log(System.Logger.Level.INFO, GameMessages.PLAYER_CHOSE, move.getDisplayName());&#10;                return move;&#10;&#10;            } catch (NumberFormatException e) {&#10;                outputLogger.log(System.Logger.Level.WARNING, GameMessages.INVALID_INPUT_FORMAT);&#10;                logger.log(System.Logger.Level.DEBUG, GameMessages.INVALID_NUMBER_FORMAT);&#10;            } catch (IllegalArgumentException e) {&#10;                outputLogger.log(System.Logger.Level.WARNING, e.getMessage());&#10;                logger.log(System.Logger.Level.DEBUG, GameMessages.INVALID_MOVE_CHOICE, e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    private void displayMoveOptions() {&#10;        StringBuilder options = new StringBuilder(GameMessages.CHOOSE_MOVE + &quot;\n&quot;);&#10;        for (Move move : Move.values()) {&#10;            options.append(&quot;  &quot;).append(move.getInputOption()).append(&quot;\n&quot;);&#10;        }&#10;        outputLogger.log(System.Logger.Level.INFO, options.toString().trim());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/service/MatchResult.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/service/MatchResult.java" />
              <option name="updatedContent" value="package com.imc.game.service;&#10;&#10;/**&#10; * Immutable record representing the result of a complete match.&#10; */&#10;public record MatchResult(&#10;    String player1Name,&#10;    int player1Wins,&#10;    String player2Name,&#10;    int player2Wins&#10;) {&#10;    &#10;    public boolean isPlayer1Winner() {&#10;        return player1Wins &gt; player2Wins;&#10;    }&#10;    &#10;    public boolean isPlayer2Winner() {&#10;        return player2Wins &gt; player1Wins;&#10;    }&#10;    &#10;    public boolean isTied() {&#10;        return player1Wins == player2Wins;&#10;    }&#10;    &#10;    public String getWinnerName() {&#10;        if (isPlayer1Winner()) return player1Name;&#10;        if (isPlayer2Winner()) return player2Name;&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/service/MatchService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/service/MatchService.java" />
              <option name="originalContent" value="package com.imc.game.service;&#10;&#10;import com.imc.game.domain.GameResult;&#10;import com.imc.game.domain.Player;&#10;import com.imc.game.engine.GameEngine;&#10;&#10;/**&#10; * Manages a complete match of 3 rounds between two players.&#10; */&#10;public class MatchService {&#10;&#10;    private static final System.Logger logger = System.getLogger(MatchService.class.getName());&#10;    private static final int ROUNDS_PER_MATCH = 3;&#10;&#10;    private final GameEngine gameEngine;&#10;&#10;    public MatchService(GameEngine gameEngine) {&#10;        this.gameEngine = gameEngine;&#10;    }&#10;&#10;    public MatchResult playMatch(Player player1, Player player2) {&#10;        int player1Wins = 0;&#10;        int player2Wins = 0;&#10;&#10;        for (int round = 1; round &lt;= ROUNDS_PER_MATCH; round++) {&#10;            logger.log(System.Logger.Level.INFO, &quot;\n--- Round {0} ---&quot;, round);&#10;&#10;            GameResult result = gameEngine.playRound(player1, player2);&#10;            gameEngine.displayResult(result);&#10;&#10;            if (!result.isDraw()) {&#10;                if (result.winnerName().equals(player1.getName())) {&#10;                    player1Wins++;&#10;                } else {&#10;                    player2Wins++;&#10;                }&#10;            }&#10;&#10;            logger.log(System.Logger.Level.INFO, &quot;Score: {0} {1} - {2} {3}&quot;,&#10;                      player1.getName(), player1Wins, player2.getName(), player2Wins);&#10;        }&#10;&#10;        return new MatchResult(player1.getName(), player1Wins, player2.getName(), player2Wins);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.service;&#10;&#10;import com.imc.game.constants.GameMessages;&#10;import com.imc.game.domain.GameResult;&#10;import com.imc.game.domain.Player;&#10;import com.imc.game.engine.GameEngine;&#10;&#10;/**&#10; * Manages a complete match of 3 rounds between two players.&#10; */&#10;public class MatchService {&#10;&#10;    private static final System.Logger logger = System.getLogger(MatchService.class.getName());&#10;    private static final int ROUNDS_PER_MATCH = 3;&#10;&#10;    private final GameEngine gameEngine;&#10;&#10;    public MatchService(GameEngine gameEngine) {&#10;        this.gameEngine = gameEngine;&#10;    }&#10;&#10;    public MatchResult playMatch(Player player1, Player player2) {&#10;        int player1Wins = 0;&#10;        int player2Wins = 0;&#10;&#10;        for (int round = 1; round &lt;= ROUNDS_PER_MATCH; round++) {&#10;            logger.log(System.Logger.Level.INFO, GameMessages.ROUND_HEADER, round);&#10;&#10;            GameResult result = gameEngine.playRound(player1, player2);&#10;            gameEngine.displayResult(result);&#10;&#10;            if (!result.isDraw()) {&#10;                if (result.winnerName().equals(player1.getName())) {&#10;                    player1Wins++;&#10;                } else {&#10;                    player2Wins++;&#10;                }&#10;            }&#10;&#10;            logger.log(System.Logger.Level.INFO, GameMessages.SCORE_FORMAT,&#10;                      player1.getName(), player1Wins, player2.getName(), player2Wins);&#10;        }&#10;&#10;        return new MatchResult(player1.getName(), player1Wins, player2.getName(), player2Wins);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/ui/ConsoleUserInterface.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/ui/ConsoleUserInterface.java" />
              <option name="updatedContent" value="package com.imc.game.ui;&#10;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Console-based implementation of UserInterface.&#10; */&#10;public class ConsoleUserInterface implements UserInterface {&#10;    &#10;    private static final System.Logger logger = System.getLogger(ConsoleUserInterface.class.getName());&#10;    private final Scanner scanner;&#10;    &#10;    public ConsoleUserInterface(Scanner scanner) {&#10;        this.scanner = scanner;&#10;    }&#10;    &#10;    @Override&#10;    public void displayMessage(String message) {&#10;        logger.log(System.Logger.Level.INFO, message);&#10;    }&#10;    &#10;    @Override&#10;    public void displayWarning(String message) {&#10;        logger.log(System.Logger.Level.WARNING, message);&#10;    }&#10;    &#10;    @Override&#10;    public String readInput() {&#10;        return scanner.nextLine().trim();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/imc/game/ui/UserInterface.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/imc/game/ui/UserInterface.java" />
              <option name="updatedContent" value="package com.imc.game.ui;&#10;&#10;/**&#10; * Interface for handling user input and output operations.&#10; * Allows for different implementations (console, GUI, etc.)&#10; */&#10;public interface UserInterface {&#10;    &#10;    void displayMessage(String message);&#10;    &#10;    void displayWarning(String message);&#10;    &#10;    String readInput();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/logback.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/logback.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;configuration&gt;&#10;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;&#10;        &lt;encoder&gt;&#10;            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;&#10;        &lt;/encoder&gt;&#10;    &lt;/appender&gt;&#10;&#10;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;&#10;        &lt;file&gt;logs/rock-paper-scissors.log&lt;/file&gt;&#10;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;&#10;            &lt;fileNamePattern&gt;logs/rock-paper-scissors.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;&#10;            &lt;maxHistory&gt;30&lt;/maxHistory&gt;&#10;        &lt;/rollingPolicy&gt;&#10;        &lt;encoder&gt;&#10;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;&#10;        &lt;/encoder&gt;&#10;    &lt;/appender&gt;&#10;&#10;    &lt;root level=&quot;INFO&quot;&gt;&#10;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;&#10;    &lt;/root&gt;&#10;&lt;/configuration&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/logging.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/logging.properties" />
              <option name="updatedContent" value="# Java Logging Configuration&#10;# Set root logger level&#10;.level = INFO&#10;&#10;# Console Handler configuration&#10;handlers = java.util.logging.ConsoleHandler&#10;&#10;# Console Handler level&#10;java.util.logging.ConsoleHandler.level = INFO&#10;&#10;# Use simple formatter to show only the message without timestamp and class info&#10;java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter&#10;&#10;# Configure SimpleFormatter to show only the log message&#10;java.util.logging.SimpleFormatter.format = %5$s%n" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/domain/GameResultTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/domain/GameResultTest.java" />
              <option name="updatedContent" value="package com.imc.game.domain;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@DisplayName(&quot;GameResult Tests&quot;)&#10;class GameResultTest {&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should create correct GameResult when player1 wins&quot;)&#10;    void shouldCreateCorrectGameResultWhenPlayer1Wins() {&#10;        GameResult result = GameResult.of(&quot;Alice&quot;, Move.ROCK, &quot;Bob&quot;, Move.SCISSORS);&#10;        &#10;        assertEquals(&quot;Alice&quot;, result.player1Name());&#10;        assertEquals(Move.ROCK, result.player1Move());&#10;        assertEquals(&quot;Bob&quot;, result.player2Name());&#10;        assertEquals(Move.SCISSORS, result.player2Move());&#10;        assertEquals(BattleResult.WIN, result.player1Result());&#10;        assertEquals(&quot;Alice&quot;, result.winnerName());&#10;        assertFalse(result.isDraw());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should create correct GameResult when player2 wins&quot;)&#10;    void shouldCreateCorrectGameResultWhenPlayer2Wins() {&#10;        GameResult result = GameResult.of(&quot;Alice&quot;, Move.ROCK, &quot;Bob&quot;, Move.PAPER);&#10;        &#10;        assertEquals(&quot;Alice&quot;, result.player1Name());&#10;        assertEquals(Move.ROCK, result.player1Move());&#10;        assertEquals(&quot;Bob&quot;, result.player2Name());&#10;        assertEquals(Move.PAPER, result.player2Move());&#10;        assertEquals(BattleResult.LOSE, result.player1Result());&#10;        assertEquals(&quot;Bob&quot;, result.winnerName());&#10;        assertFalse(result.isDraw());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should create correct GameResult when draw&quot;)&#10;    void shouldCreateCorrectGameResultWhenDraw() {&#10;        GameResult result = GameResult.of(&quot;Alice&quot;, Move.ROCK, &quot;Bob&quot;, Move.ROCK);&#10;        &#10;        assertEquals(&quot;Alice&quot;, result.player1Name());&#10;        assertEquals(Move.ROCK, result.player1Move());&#10;        assertEquals(&quot;Bob&quot;, result.player2Name());&#10;        assertEquals(Move.ROCK, result.player2Move());&#10;        assertEquals(BattleResult.DRAW, result.player1Result());&#10;        assertNull(result.winnerName());&#10;        assertTrue(result.isDraw());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle all possible move combinations correctly&quot;)&#10;    void shouldHandleAllMoveCombinationsCorrectly() {&#10;        // Test all winning combinations for player1&#10;        GameResult rockVsScissors = GameResult.of(&quot;P1&quot;, Move.ROCK, &quot;P2&quot;, Move.SCISSORS);&#10;        assertEquals(&quot;P1&quot;, rockVsScissors.winnerName());&#10;        &#10;        GameResult paperVsRock = GameResult.of(&quot;P1&quot;, Move.PAPER, &quot;P2&quot;, Move.ROCK);&#10;        assertEquals(&quot;P1&quot;, paperVsRock.winnerName());&#10;        &#10;        GameResult scissorsVsPaper = GameResult.of(&quot;P1&quot;, Move.SCISSORS, &quot;P2&quot;, Move.PAPER);&#10;        assertEquals(&quot;P1&quot;, scissorsVsPaper.winnerName());&#10;        &#10;        // Test all winning combinations for player2&#10;        GameResult scissorsVsRock = GameResult.of(&quot;P1&quot;, Move.SCISSORS, &quot;P2&quot;, Move.ROCK);&#10;        assertEquals(&quot;P2&quot;, scissorsVsRock.winnerName());&#10;        &#10;        GameResult rockVsPaper = GameResult.of(&quot;P1&quot;, Move.ROCK, &quot;P2&quot;, Move.PAPER);&#10;        assertEquals(&quot;P2&quot;, rockVsPaper.winnerName());&#10;        &#10;        GameResult paperVsScissors = GameResult.of(&quot;P1&quot;, Move.PAPER, &quot;P2&quot;, Move.SCISSORS);&#10;        assertEquals(&quot;P2&quot;, paperVsScissors.winnerName());&#10;        &#10;        // Test all draw combinations&#10;        GameResult rockVsRock = GameResult.of(&quot;P1&quot;, Move.ROCK, &quot;P2&quot;, Move.ROCK);&#10;        assertTrue(rockVsRock.isDraw());&#10;        &#10;        GameResult paperVsPaper = GameResult.of(&quot;P1&quot;, Move.PAPER, &quot;P2&quot;, Move.PAPER);&#10;        assertTrue(paperVsPaper.isDraw());&#10;        &#10;        GameResult scissorsVsScissors = GameResult.of(&quot;P1&quot;, Move.SCISSORS, &quot;P2&quot;, Move.SCISSORS);&#10;        assertTrue(scissorsVsScissors.isDraw());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/domain/MoveTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/domain/MoveTest.java" />
              <option name="updatedContent" value="package com.imc.game.domain;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.params.ParameterizedTest;&#10;import org.junit.jupiter.params.provider.ValueSource;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@DisplayName(&quot;Move Tests&quot;)&#10;class MoveTest {&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should create correct moves from valid input&quot;)&#10;    void shouldCreateCorrectMovesFromValidInput() {&#10;        assertEquals(Move.ROCK, Move.fromInput(1));&#10;        assertEquals(Move.PAPER, Move.fromInput(2));&#10;        assertEquals(Move.SCISSORS, Move.fromInput(3));&#10;    }&#10;&#10;    @ParameterizedTest&#10;    @ValueSource(ints = {0, 4, 5, -1, 10})&#10;    @DisplayName(&quot;Should throw exception for invalid input values&quot;)&#10;    void shouldThrowExceptionForInvalidInput(int invalidInput) {&#10;        IllegalArgumentException exception = assertThrows(&#10;            IllegalArgumentException.class,&#10;            () -&gt; Move.fromInput(invalidInput)&#10;        );&#10;        assertEquals(&quot;Please enter 1, 2, or 3.&quot;, exception.getMessage());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Rock should beat Scissors&quot;)&#10;    void rockShouldBeatScissors() {&#10;        assertTrue(Move.ROCK.beats(Move.SCISSORS));&#10;        assertFalse(Move.SCISSORS.beats(Move.ROCK));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Paper should beat Rock&quot;)&#10;    void paperShouldBeatRock() {&#10;        assertTrue(Move.PAPER.beats(Move.ROCK));&#10;        assertFalse(Move.ROCK.beats(Move.PAPER));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Scissors should beat Paper&quot;)&#10;    void scissorsShouldBeatPaper() {&#10;        assertTrue(Move.SCISSORS.beats(Move.PAPER));&#10;        assertFalse(Move.PAPER.beats(Move.SCISSORS));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Same moves should not beat each other&quot;)&#10;    void sameMovesDoNotBeatEachOther() {&#10;        assertFalse(Move.ROCK.beats(Move.ROCK));&#10;        assertFalse(Move.PAPER.beats(Move.PAPER));&#10;        assertFalse(Move.SCISSORS.beats(Move.SCISSORS));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return WIN when this move beats other&quot;)&#10;    void shouldReturnWinWhenThisBeatsOther() {&#10;        assertEquals(BattleResult.WIN, Move.ROCK.against(Move.SCISSORS));&#10;        assertEquals(BattleResult.WIN, Move.PAPER.against(Move.ROCK));&#10;        assertEquals(BattleResult.WIN, Move.SCISSORS.against(Move.PAPER));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return LOSE when other move beats this&quot;)&#10;    void shouldReturnLoseWhenOtherBeatsThis() {&#10;        assertEquals(BattleResult.LOSE, Move.SCISSORS.against(Move.ROCK));&#10;        assertEquals(BattleResult.LOSE, Move.ROCK.against(Move.PAPER));&#10;        assertEquals(BattleResult.LOSE, Move.PAPER.against(Move.SCISSORS));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return DRAW when moves are the same&quot;)&#10;    void shouldReturnDrawWhenMovesAreTheSame() {&#10;        assertEquals(BattleResult.DRAW, Move.ROCK.against(Move.ROCK));&#10;        assertEquals(BattleResult.DRAW, Move.PAPER.against(Move.PAPER));&#10;        assertEquals(BattleResult.DRAW, Move.SCISSORS.against(Move.SCISSORS));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct input values&quot;)&#10;    void shouldReturnCorrectInputValues() {&#10;        assertEquals(1, Move.ROCK.getInputValue());&#10;        assertEquals(2, Move.PAPER.getInputValue());&#10;        assertEquals(3, Move.SCISSORS.getInputValue());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct display names&quot;)&#10;    void shouldReturnCorrectDisplayNames() {&#10;        assertEquals(&quot;Rock&quot;, Move.ROCK.getDisplayName());&#10;        assertEquals(&quot;Paper&quot;, Move.PAPER.getDisplayName());&#10;        assertEquals(&quot;Scissors&quot;, Move.SCISSORS.getDisplayName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should format input options correctly&quot;)&#10;    void shouldFormatInputOptionsCorrectly() {&#10;        assertEquals(&quot;1 - Rock&quot;, Move.ROCK.getInputOption());&#10;        assertEquals(&quot;2 - Paper&quot;, Move.PAPER.getInputOption());&#10;        assertEquals(&quot;3 - Scissors&quot;, Move.SCISSORS.getInputOption());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/engine/GameEngineTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/engine/GameEngineTest.java" />
              <option name="updatedContent" value="package com.imc.game.engine;&#10;&#10;import com.imc.game.domain.GameResult;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.mockito.Mock;&#10;import org.mockito.MockitoAnnotations;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;@DisplayName(&quot;GameEngine Tests&quot;)&#10;class GameEngineTest {&#10;&#10;    @Mock&#10;    private Player mockPlayer1;&#10;    &#10;    @Mock&#10;    private Player mockPlayer2;&#10;    &#10;    private GameEngine gameEngine;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        MockitoAnnotations.openMocks(this);&#10;        gameEngine = new GameEngine();&#10;        &#10;        when(mockPlayer1.getName()).thenReturn(&quot;Alice&quot;);&#10;        when(mockPlayer2.getName()).thenReturn(&quot;Bob&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should execute complete round and return correct result&quot;)&#10;    void shouldExecuteCompleteRoundAndReturnCorrectResult() {&#10;        when(mockPlayer1.getMove()).thenReturn(Move.ROCK);&#10;        when(mockPlayer2.getMove()).thenReturn(Move.SCISSORS);&#10;        &#10;        GameResult result = gameEngine.playRound(mockPlayer1, mockPlayer2);&#10;        &#10;        assertEquals(&quot;Alice&quot;, result.player1Name());&#10;        assertEquals(Move.ROCK, result.player1Move());&#10;        assertEquals(&quot;Bob&quot;, result.player2Name());&#10;        assertEquals(Move.SCISSORS, result.player2Move());&#10;        assertEquals(&quot;Alice&quot;, result.winnerName());&#10;        assertFalse(result.isDraw());&#10;        &#10;        verify(mockPlayer1).getMove();&#10;        verify(mockPlayer2).getMove();&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle draw scenario&quot;)&#10;    void shouldHandleDrawScenario() {&#10;        when(mockPlayer1.getMove()).thenReturn(Move.PAPER);&#10;        when(mockPlayer2.getMove()).thenReturn(Move.PAPER);&#10;        &#10;        GameResult result = gameEngine.playRound(mockPlayer1, mockPlayer2);&#10;        &#10;        assertEquals(&quot;Alice&quot;, result.player1Name());&#10;        assertEquals(Move.PAPER, result.player1Move());&#10;        assertEquals(&quot;Bob&quot;, result.player2Name());&#10;        assertEquals(Move.PAPER, result.player2Move());&#10;        assertNull(result.winnerName());&#10;        assertTrue(result.isDraw());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle all winning combinations&quot;)&#10;    void shouldHandleAllWinningCombinations() {&#10;        // Test Rock beats Scissors&#10;        when(mockPlayer1.getMove()).thenReturn(Move.ROCK);&#10;        when(mockPlayer2.getMove()).thenReturn(Move.SCISSORS);&#10;        GameResult result1 = gameEngine.playRound(mockPlayer1, mockPlayer2);&#10;        assertEquals(&quot;Alice&quot;, result1.winnerName());&#10;        &#10;        // Test Paper beats Rock&#10;        when(mockPlayer1.getMove()).thenReturn(Move.PAPER);&#10;        when(mockPlayer2.getMove()).thenReturn(Move.ROCK);&#10;        GameResult result2 = gameEngine.playRound(mockPlayer1, mockPlayer2);&#10;        assertEquals(&quot;Alice&quot;, result2.winnerName());&#10;        &#10;        // Test Scissors beats Paper&#10;        when(mockPlayer1.getMove()).thenReturn(Move.SCISSORS);&#10;        when(mockPlayer2.getMove()).thenReturn(Move.PAPER);&#10;        GameResult result3 = gameEngine.playRound(mockPlayer1, mockPlayer2);&#10;        assertEquals(&quot;Alice&quot;, result3.winnerName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should call displayResult without throwing exceptions&quot;)&#10;    void shouldCallDisplayResultWithoutThrowingExceptions() {&#10;        GameResult result = GameResult.of(&quot;Alice&quot;, Move.ROCK, &quot;Bob&quot;, Move.SCISSORS);&#10;        &#10;        assertDoesNotThrow(() -&gt; gameEngine.displayResult(result));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/player/ComputerPlayerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/player/ComputerPlayerTest.java" />
              <option name="originalContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.domain.Move;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.RepeatedTest;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@DisplayName(&quot;ComputerPlayer Tests&quot;)&#10;class ComputerPlayerTest {&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct name&quot;)&#10;    void shouldReturnCorrectName() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;TestComputer&quot;);&#10;        assertEquals(&quot;TestComputer&quot;, player.getName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return a valid move&quot;)&#10;    void shouldReturnValidMove() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;Computer&quot;);&#10;        Move move = player.getMove();&#10;&#10;        assertNotNull(move);&#10;        assertTrue(move == Move.ROCK || move == Move.PAPER || move == Move.SCISSORS);&#10;    }&#10;&#10;    @RepeatedTest(100)&#10;    @DisplayName(&quot;Should always return valid moves across multiple calls&quot;)&#10;    void shouldAlwaysReturnValidMovesAcrossMultipleCalls() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;Computer&quot;);&#10;        Move move = player.getMove();&#10;&#10;        assertNotNull(move);&#10;        assertTrue(move == Move.ROCK || move == Move.PAPER || move == Move.SCISSORS);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should eventually produce all three moves&quot;)&#10;    void shouldEventuallyProduceAllThreeMoves() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;Computer&quot;);&#10;        boolean hasRock = false, hasPaper = false, hasScissors = false;&#10;&#10;        // Try up to 1000 times to get all three moves (extremely high probability)&#10;        for (int i = 0; i &lt; 1000 &amp;&amp; !(hasRock &amp;&amp; hasPaper &amp;&amp; hasScissors); i++) {&#10;            Move move = player.getMove();&#10;            switch (move) {&#10;                case ROCK -&gt; hasRock = true;&#10;                case PAPER -&gt; hasPaper = true;&#10;                case SCISSORS -&gt; hasScissors = true;&#10;            }&#10;        }&#10;&#10;        assertTrue(hasRock, &quot;Computer should eventually choose Rock&quot;);&#10;        assertTrue(hasPaper, &quot;Computer should eventually choose Paper&quot;);&#10;        assertTrue(hasScissors, &quot;Computer should eventually choose Scissors&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.domain.Move;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@DisplayName(&quot;ComputerPlayer Tests&quot;)&#10;class ComputerPlayerTest {&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct name&quot;)&#10;    void shouldReturnCorrectName() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;TestComputer&quot;);&#10;        assertEquals(&quot;TestComputer&quot;, player.getName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return a valid move&quot;)&#10;    void shouldReturnValidMove() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;Computer&quot;);&#10;        Move move = player.getMove();&#10;&#10;        assertNotNull(move);&#10;        assertTrue(move == Move.ROCK || move == Move.PAPER || move == Move.SCISSORS);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should eventually produce all three moves&quot;)&#10;    void shouldEventuallyProduceAllThreeMoves() {&#10;        ComputerPlayer player = new ComputerPlayer(&quot;Computer&quot;);&#10;        boolean hasRock = false, hasPaper = false, hasScissors = false;&#10;&#10;        // Try up to 1000 times to get all three moves (extremely high probability)&#10;        for (int i = 0; i &lt; 1000 &amp;&amp; !(hasRock &amp;&amp; hasPaper &amp;&amp; hasScissors); i++) {&#10;            Move move = player.getMove();&#10;            switch (move) {&#10;                case ROCK -&gt; hasRock = true;&#10;                case PAPER -&gt; hasPaper = true;&#10;                case SCISSORS -&gt; hasScissors = true;&#10;            }&#10;        }&#10;&#10;        assertTrue(hasRock, &quot;Computer should eventually choose Rock&quot;);&#10;        assertTrue(hasPaper, &quot;Computer should eventually choose Paper&quot;);&#10;        assertTrue(hasScissors, &quot;Computer should eventually choose Scissors&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/player/HumanPlayerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/player/HumanPlayerTest.java" />
              <option name="originalContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.domain.Move;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.mockito.Mock;&#10;import org.mockito.MockitoAnnotations;&#10;&#10;import java.io.StringReader;&#10;import java.util.Scanner;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.anyString;&#10;import static org.mockito.Mockito.*;&#10;&#10;@DisplayName(&quot;HumanPlayer Tests&quot;)&#10;class HumanPlayerTest {&#10;&#10;    @Mock&#10;    private System.Logger mockLogger;&#10;&#10;    private HumanPlayer player;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        MockitoAnnotations.openMocks(this);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct name&quot;)&#10;    void shouldReturnCorrectName() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;1\n&quot;));&#10;        player = new HumanPlayer(&quot;TestPlayer&quot;, scanner, mockLogger);&#10;&#10;        assertEquals(&quot;TestPlayer&quot;, player.getName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return ROCK when user enters 1&quot;)&#10;    void shouldReturnRockWhenUserEnters1() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;1\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.ROCK, move);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return PAPER when user enters 2&quot;)&#10;    void shouldReturnPaperWhenUserEnters2() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;2\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.PAPER, move);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return SCISSORS when user enters 3&quot;)&#10;    void shouldReturnScissorsWhenUserEnters3() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;3\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.SCISSORS, move);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle invalid input and retry&quot;)&#10;    void shouldHandleInvalidInputAndRetry() {&#10;        // First invalid input (4), then valid input (2)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;4\n2\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.PAPER, move);&#10;&#10;        // Verify warning was logged for invalid input&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle non-numeric input and retry&quot;)&#10;    void shouldHandleNonNumericInputAndRetry() {&#10;        // First invalid input (abc), then valid input (1)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;abc\n1\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.ROCK, move);&#10;&#10;        // Verify warning was logged for invalid format&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle empty input and retry&quot;)&#10;    void shouldHandleEmptyInputAndRetry() {&#10;        // First empty input, then valid input (3)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;\n3\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.SCISSORS, move);&#10;&#10;        // Verify warning was logged for empty input&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle multiple invalid inputs before valid one&quot;)&#10;    void shouldHandleMultipleInvalidInputsBeforeValidOne() {&#10;        // Multiple invalid inputs, then valid input (1)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;0\nabc\n\n5\n1\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.ROCK, move);&#10;&#10;        // Verify multiple warnings were logged&#10;        verify(mockLogger, atLeast(4)).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should log move selection&quot;)&#10;    void shouldLogMoveSelection() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;2\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        player.getMove();&#10;&#10;        // Verify that the move choice was logged&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.INFO), anyString(), eq(&quot;Paper&quot;));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.imc.game.player;&#10;&#10;import com.imc.game.domain.Move;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.mockito.Mock;&#10;import org.mockito.MockitoAnnotations;&#10;&#10;import java.io.StringReader;&#10;import java.util.Scanner;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.anyString;&#10;import static org.mockito.Mockito.*;&#10;&#10;@DisplayName(&quot;HumanPlayer Tests&quot;)&#10;class HumanPlayerTest {&#10;&#10;    @Mock&#10;    private System.Logger mockLogger;&#10;&#10;    private HumanPlayer player;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        MockitoAnnotations.openMocks(this);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct name&quot;)&#10;    void shouldReturnCorrectName() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;1\n&quot;));&#10;        player = new HumanPlayer(&quot;TestPlayer&quot;, scanner, mockLogger);&#10;&#10;        assertEquals(&quot;TestPlayer&quot;, player.getName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return ROCK when user enters 1&quot;)&#10;    void shouldReturnRockWhenUserEnters1() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;1\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.ROCK, move);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return PAPER when user enters 2&quot;)&#10;    void shouldReturnPaperWhenUserEnters2() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;2\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.PAPER, move);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return SCISSORS when user enters 3&quot;)&#10;    void shouldReturnScissorsWhenUserEnters3() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;3\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.SCISSORS, move);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle invalid input and retry&quot;)&#10;    void shouldHandleInvalidInputAndRetry() {&#10;        // First invalid input (4), then valid input (2)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;4\n2\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.PAPER, move);&#10;&#10;        // Verify warning was logged for invalid input&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle non-numeric input and retry&quot;)&#10;    void shouldHandleNonNumericInputAndRetry() {&#10;        // First invalid input (abc), then valid input (1)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;abc\n1\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.ROCK, move);&#10;&#10;        // Verify warning was logged for invalid format&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle empty input and retry&quot;)&#10;    void shouldHandleEmptyInputAndRetry() {&#10;        // First empty input, then valid input (3)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;\n3\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.SCISSORS, move);&#10;&#10;        // Verify warning was logged for empty input&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle multiple invalid inputs before valid one&quot;)&#10;    void shouldHandleMultipleInvalidInputsBeforeValidOne() {&#10;        // Multiple invalid inputs, then valid input (1)&#10;        Scanner scanner = new Scanner(new StringReader(&quot;0\nabc\n\n5\n1\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        Move move = player.getMove();&#10;        assertEquals(Move.ROCK, move);&#10;&#10;        // Verify multiple warnings were logged&#10;        verify(mockLogger, atLeast(4)).log(eq(System.Logger.Level.WARNING), anyString());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should display move options and prompt correctly&quot;)&#10;    void shouldDisplayMoveOptionsAndPromptCorrectly() {&#10;        Scanner scanner = new Scanner(new StringReader(&quot;2\n&quot;));&#10;        player = new HumanPlayer(&quot;Player&quot;, scanner, mockLogger);&#10;&#10;        player.getMove();&#10;&#10;        // Verify that the move options were displayed&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.INFO), contains(&quot;Choose your move&quot;));&#10;        // Verify that the choice prompt was displayed&#10;        verify(mockLogger, atLeastOnce()).log(eq(System.Logger.Level.INFO), eq(&quot;Enter your choice: &quot;));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/service/MatchResultTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/service/MatchResultTest.java" />
              <option name="updatedContent" value="package com.imc.game.service;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@DisplayName(&quot;MatchResult Tests&quot;)&#10;class MatchResultTest {&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should correctly identify player1 as winner&quot;)&#10;    void shouldCorrectlyIdentifyPlayer1AsWinner() {&#10;        MatchResult result = new MatchResult(&quot;Alice&quot;, 2, &quot;Bob&quot;, 1);&#10;        &#10;        assertTrue(result.isPlayer1Winner());&#10;        assertFalse(result.isPlayer2Winner());&#10;        assertFalse(result.isTied());&#10;        assertEquals(&quot;Alice&quot;, result.getWinnerName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should correctly identify player2 as winner&quot;)&#10;    void shouldCorrectlyIdentifyPlayer2AsWinner() {&#10;        MatchResult result = new MatchResult(&quot;Alice&quot;, 1, &quot;Bob&quot;, 2);&#10;        &#10;        assertFalse(result.isPlayer1Winner());&#10;        assertTrue(result.isPlayer2Winner());&#10;        assertFalse(result.isTied());&#10;        assertEquals(&quot;Bob&quot;, result.getWinnerName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should correctly identify tied match&quot;)&#10;    void shouldCorrectlyIdentifyTiedMatch() {&#10;        MatchResult result = new MatchResult(&quot;Alice&quot;, 1, &quot;Bob&quot;, 1);&#10;        &#10;        assertFalse(result.isPlayer1Winner());&#10;        assertFalse(result.isPlayer2Winner());&#10;        assertTrue(result.isTied());&#10;        assertNull(result.getWinnerName());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle perfect game scenario&quot;)&#10;    void shouldHandlePerfectGameScenario() {&#10;        MatchResult result = new MatchResult(&quot;Player&quot;, 3, &quot;Computer&quot;, 0);&#10;        &#10;        assertTrue(result.isPlayer1Winner());&#10;        assertEquals(&quot;Player&quot;, result.getWinnerName());&#10;        assertEquals(3, result.player1Wins());&#10;        assertEquals(0, result.player2Wins());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle zero-zero tie&quot;)&#10;    void shouldHandleZeroZeroTie() {&#10;        MatchResult result = new MatchResult(&quot;Player&quot;, 0, &quot;Computer&quot;, 0);&#10;        &#10;        assertTrue(result.isTied());&#10;        assertNull(result.getWinnerName());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/imc/game/service/MatchServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/imc/game/service/MatchServiceTest.java" />
              <option name="updatedContent" value="package com.imc.game.service;&#10;&#10;import com.imc.game.domain.GameResult;&#10;import com.imc.game.domain.Move;&#10;import com.imc.game.domain.Player;&#10;import com.imc.game.engine.GameEngine;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.mockito.Mock;&#10;import org.mockito.MockitoAnnotations;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;@DisplayName(&quot;MatchService Tests&quot;)&#10;class MatchServiceTest {&#10;&#10;    @Mock&#10;    private GameEngine mockGameEngine;&#10;    &#10;    @Mock&#10;    private Player mockPlayer1;&#10;    &#10;    @Mock&#10;    private Player mockPlayer2;&#10;    &#10;    private MatchService matchService;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        MockitoAnnotations.openMocks(this);&#10;        matchService = new MatchService(mockGameEngine);&#10;        &#10;        when(mockPlayer1.getName()).thenReturn(&quot;Player1&quot;);&#10;        when(mockPlayer2.getName()).thenReturn(&quot;Player2&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should play exactly 3 rounds&quot;)&#10;    void shouldPlayExactly3Rounds() {&#10;        // Mock 3 game results where Player1 wins all&#10;        GameResult mockResult = new GameResult(&quot;Player1&quot;, Move.ROCK, &quot;Player2&quot;, Move.SCISSORS, null, &quot;Player1&quot;);&#10;        when(mockGameEngine.playRound(mockPlayer1, mockPlayer2)).thenReturn(mockResult);&#10;        &#10;        matchService.playMatch(mockPlayer1, mockPlayer2);&#10;        &#10;        // Verify playRound was called exactly 3 times&#10;        verify(mockGameEngine, times(3)).playRound(mockPlayer1, mockPlayer2);&#10;        verify(mockGameEngine, times(3)).displayResult(any(GameResult.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should return correct match result when Player1 wins&quot;)&#10;    void shouldReturnCorrectMatchResultWhenPlayer1Wins() {&#10;        // Player1 wins 2 out of 3 rounds&#10;        GameResult player1Win = GameResult.of(&quot;Player1&quot;, Move.ROCK, &quot;Player2&quot;, Move.SCISSORS);&#10;        GameResult player2Win = GameResult.of(&quot;Player1&quot;, Move.ROCK, &quot;Player2&quot;, Move.PAPER);&#10;        GameResult player1Win2 = GameResult.of(&quot;Player1&quot;, Move.PAPER, &quot;Player2&quot;, Move.ROCK);&#10;        &#10;        when(mockGameEngine.playRound(mockPlayer1, mockPlayer2))&#10;            .thenReturn(player1Win, player2Win, player1Win2);&#10;        &#10;        MatchResult result = matchService.playMatch(mockPlayer1, mockPlayer2);&#10;        &#10;        assertEquals(&quot;Player1&quot;, result.player1Name());&#10;        assertEquals(&quot;Player2&quot;, result.player2Name());&#10;        assertEquals(2, result.player1Wins());&#10;        assertEquals(1, result.player2Wins());&#10;        assertTrue(result.isPlayer1Winner());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle draws correctly&quot;)&#10;    void shouldHandleDrawsCorrectly() {&#10;        // All 3 rounds are draws&#10;        GameResult draw1 = GameResult.of(&quot;Player1&quot;, Move.ROCK, &quot;Player2&quot;, Move.ROCK);&#10;        GameResult draw2 = GameResult.of(&quot;Player1&quot;, Move.PAPER, &quot;Player2&quot;, Move.PAPER);&#10;        GameResult draw3 = GameResult.of(&quot;Player1&quot;, Move.SCISSORS, &quot;Player2&quot;, Move.SCISSORS);&#10;        &#10;        when(mockGameEngine.playRound(mockPlayer1, mockPlayer2))&#10;            .thenReturn(draw1, draw2, draw3);&#10;        &#10;        MatchResult result = matchService.playMatch(mockPlayer1, mockPlayer2);&#10;        &#10;        assertEquals(0, result.player1Wins());&#10;        assertEquals(0, result.player2Wins());&#10;        assertTrue(result.isTied());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle mixed results with draws&quot;)&#10;    void shouldHandleMixedResultsWithDraws() {&#10;        // 1 win for Player1, 1 draw, 1 win for Player2&#10;        GameResult player1Win = GameResult.of(&quot;Player1&quot;, Move.ROCK, &quot;Player2&quot;, Move.SCISSORS);&#10;        GameResult draw = GameResult.of(&quot;Player1&quot;, Move.PAPER, &quot;Player2&quot;, Move.PAPER);&#10;        GameResult player2Win = GameResult.of(&quot;Player1&quot;, Move.ROCK, &quot;Player2&quot;, Move.PAPER);&#10;        &#10;        when(mockGameEngine.playRound(mockPlayer1, mockPlayer2))&#10;            .thenReturn(player1Win, draw, player2Win);&#10;        &#10;        MatchResult result = matchService.playMatch(mockPlayer1, mockPlayer2);&#10;        &#10;        assertEquals(1, result.player1Wins());&#10;        assertEquals(1, result.player2Wins());&#10;        assertTrue(result.isTied());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>